package com.conveyal.file;

import com.conveyal.r5.analyst.PersistenceBuffer;

import java.io.File;

/**
 * Store files, optionally mirroring them to cloud storage for retrieval by workers and future backend deployments.
 * These are always used as files on the local filesystem, and are treated as immutable once put into storage.
 * <p>
 * The add/remove/etc. methods are all blocking calls now for simplicity, i.e. if you add a file, all other components
 * of the system are known to be able to see it as soon as the method returns.
 * <p>
 * This does not handle storing file metadata in MongoDB. That is a separate concern. Workers for example need to get
 * files without looking into our database. Our file metadata handling component could wrap this, so all backend file
 * operations implicitly had metadata.
 * <p>
 * In the S3-based implementation we need to set content type and compression details on S3. We plan to do that by
 * inspecting the "magic number" bytes at the beginning of the file and auto-setting the content type.
 */
public interface FileStorage {

    public interface Config {
        // The local directory where files will be stored, even if they are being mirrored to a remote storage service.
        String localCacheDirectory ();
        // This is actually only needed for th S3 implementation,
        // but leaving it alone because I expect to remove this parameter entirely.
        String awsRegion();
        // This is actually only needed for the S3 implementation, it should eventually be moved.
        String bucketPrefix();
    }

    /**
     * Takes an already existing file on the local filesystem and registers it as a permanent, immutable file to be
     * made available to all analysis components including workers and future backends. If a file was uploaded in a
     * form, we can call DiskFileItem.getStoreLocation to get the file, which according to that method's Javadoc we are
     * allowed to rename to our own location. If the file was created by the backend, it should be created in a temp
     * file. Once the file is completely constructed/written out, it should be closed and then this method called on it.
     */
    void moveIntoStorage(FileStorageKey fileStorageKey, File file);

    /**
     * Move the data in the buffer into permanent storage, much like moveIntoStorage(), but do not retain locally.
     * The PersistenceBuffer must be marked 'done' before it is handed to this method.
     * Treat the TAUI category in a special way: don't keep it locally if mirrored remotely.
     * Unlike the other file categories, it's produced on the worker (as opposed to the backend), and it will never
     * be read by the worker, so doesn't need to be kept once stored to S3. That could be a parameter but for now we'll
     * do it purely based on the file type. TAUI and in the future maybe some other kinds of results.
     *
     * This is a blocking call and should only return when the file is completely uploaded.
     * That prevents our workers from producing output faster than uploads can complete,
     * and building up a queue of waiting uploads.
     *
     * TODO use with new FileStorageKey(TAUI, analysisWorkerTask.jobId);
     * TODO eventually unify with moveIntoStorage, by wrapping File in FileStorageBuffer?
     */
    default void moveIntoStorage(FileStorageKey fileStorageKey, PersistenceBuffer persistenceBuffer) { }

    /**
     * This should be treated as immutable - never write to a file returned from this method.
     * That could be enforced by making our own class with no write methods, that only allows reading the file.
     * We may also want to set the file's access flags to read-only so exceptions will occur if we ever write.
     */
    File getFile(FileStorageKey fileStorageKey);

    /**
     * Get the URL for the File located at the FileStorageKey. This can be a file:// URL when running locally or a URL
     * available on the web generated by S3.
     */
    String getURL(FileStorageKey fileStorageKey);

    /**
     * Delete the File located at the FileStorageKey.
     */
    void delete(FileStorageKey fileStorageKey);

    /**
     * When a new server is spun up there will be no local files. In instances where we derive files from other files
     * (ex: creating Tiffs from Grids) and if they are already created we only need to return a download URL and therefore
     * not need to retrieve the file at all, it would be useful to check if the file exists in the FileStorage without
     * actually retrieving it.
     */
    boolean exists(FileStorageKey fileStorageKey);
}
